#include "intersect.h"

#define _pow2(x) ((x) * (x)) 
#define _x1(x) x.shape.plane.x1
#define _y1(x) x.shape.plane.y1
#define _z1(x) x.shape.plane.z1
#define _x2(x) x.shape.plane.x2
#define _y2(x) x.shape.plane.y2
#define _z2(x) x.shape.plane.z2
#define _x3(x) x.shape.plane.x3
#define _y3(x) x.shape.plane.y3
#define _z3(x) x.shape.plane.z3

/**
 * Intersect sphere function
 */
int intersect_sphere(spu_ray_t ray, 
                     spu_shape_t shape, 
                     float* rayt) { 
  spu_point_t o  = ray.o;
  spu_vector_t d = ray.d;
  spu_point_t c  = shape.shape.sphere.o;
  float r = shape.shape.sphere.radius;
  float a = _pow2(d.x) + _pow2(d.y) + _pow2(d.z);
  float b = 2 * (o.x * d.x + o.y * d.y + o.z * d.z 
		 - c.x * d.x - c.y * d.y - c.z * d.z);
  float e = _pow2(o.x - c.x) + _pow2(o.y - c.y) + _pow2(o.z - c.z) - _pow2(r);

  // solve the quadratic equation
  float delta = _pow2(b) - 4 * a * e;
  if (delta > 0.0f) {
    *rayt = (-b - sqrtf(delta)) / (2.f * a);
    return 1;
  }
  return 0;
}

/**
 *  Intersect plane function
 */
int intersect_plane(spu_ray_t ray,
		    spu_shape_t s,
		    float* rayt) {
  
  float a = _y1(s) * (_z2(s) - _z3(s)) + _y2(s) 
    * (_z3(s) - _z1(s)) + _y3(s) * (_z1(s) - _z2(s));

  float b = _z1(s) * (_x2(s) - _x3(s)) + _z2(s) 
    * (_x3(s) - _x1(s)) + _z3(s) * (_x1(s) - _x2(s));

  float c = _x1(s) * (_y2(s) - _y3(s)) + _x2(s) 
    * (_y3(s) - _y1(s)) + _x3(s) * (_y1(s) - _y2(s));

  float d = _x1(s) * (_y2(s) * _z3(s) - _y3(s) * _z2(s)) 
    + _x2(s) * (_y3(s) * _z1(s) - _y1(s) * _z3(s))
    + _x3(s) * (_y1(s) * _z2(s) - _y2(s) * _z1(s));
	
  *rayt = ( d - a * ray.o.x - b * ray.o.y - c * ray.o.z ) 
    / (a * ray.d.x + b * ray.d.y + c * ray.d.z);
	
  // the intersection point
  float nx = (*rayt) * ray.d.x + ray.o.x;
  float ny = (*rayt) * ray.d.y + ray.o.y;
  float nz = (*rayt) * ray.d.z + ray.o.z;

  // do the out-of-range test
  if (_x1(s) == _x3(s)) {
    if (!((ny < _y3(s)) ^ (ny < _y1(s))))
      return 0;
    if (!((nz < _z1(s)) ^ (nz < _z3(s))))
      return 0;
  }
  else if (_y1(s) == _y3(s)) {
    if (!((nx < _x3(s)) ^ (nx < _x1(s))))
      return 0;
    if (!((nz < _z1(s)) ^ (nz < _z3(s))))
      return 0;
  }
  else if (_z1(s) == _z3(s)) {
    if (!((nx < _x1(s)) ^ (nx < _x3(s))))
      return 0;
    if (!((ny < _y1(s)) ^ (ny < _y3(s))))
      return 0;
  }

  return 1;
}

vec_float4 simd_intersect_sphere(vec_float4 ox,
				 vec_float4 oy,
				 vec_float4 oz,
				 vec_float4 dx,
				 vec_float4 dy,
				 vec_float4 dz,
				 spu_shape_t shape) {

  vec_float4 e, t, delta, rs;
  vec_uint4 flag;
  // vectorize the sphere structure
  vec_float4 r   = spu_splats(shape.shape.sphere.radius);
  vec_float4 sox = spu_splats(shape.shape.sphere.o.x);
  vec_float4 soy = spu_splats(shape.shape.sphere.o.y);
  vec_float4 soz = spu_splats(shape.shape.sphere.o.z);

  vec_float4 a = spu_madd(dx, dx, spu_madd(dy, dy, spu_mul(dz, dz)));
  vec_float4 b = spu_madd(ox, dx, spu_madd(oy, dy, spu_mul(oz, dz)));
  b = spu_sub(b, spu_madd(sox, dx, spu_madd(soy, dy, spu_mul(soz, dz))));
  b = spu_mul(spu_splats(2.0f), b);

  t = spu_sub(ox, sox);
  e = spu_mul(t, t);
  t = spu_sub(oy, soy);
  e = spu_madd(t, t, e);
  t = spu_sub(oz, soz);
  e = spu_madd(t, t, e);
  e = spu_sub(e, spu_mul(r, r));
  
  t = spu_mul(spu_splats(4.0f), spu_mul(a, e));
  delta = spu_msub(b, b, t);
  
  flag = spu_cmpgt(delta, spu_splats(0.0f));
  rs = spu_add(b, _sqrtf4(delta));
  rs = spu_mul(rs, spu_re(spu_mul(spu_splats(-2.0f), a)));
  
  rs = spu_sel(spu_splats(0.0f), rs, flag);

  return rs;
}


vec_float4 simd_intersect_plane(vec_float4 ox,
				vec_float4 oy,
				vec_float4 oz,
				vec_float4 dx,
				vec_float4 dy,
				vec_float4 dz,
				spu_shape_t shape) {

  vec_uint4 mask0 = (vec_uint4) { 0xFFFFFFFF, 0, 0, 0 };
  vec_uint4 mask1 = (vec_uint4) { 0, 0xFFFFFFFF, 0, 0 };
  vec_uint4 mask2 = (vec_uint4) { 0, 0, 0xFFFFFFFF, 0 };

  uint32_t index;
  vec_uint4 flag, cmprs[3];
  vec_float4 rs = spu_splats(0.0f);
  vec_float4 nx, ny, nz;
  
  vec_float4 x1 = spu_splats(_x1(shape));
  vec_float4 y1 = spu_splats(_y1(shape));
  vec_float4 z1 = spu_splats(_z1(shape));
  vec_float4 x2 = spu_splats(_x2(shape));
  vec_float4 y2 = spu_splats(_x2(shape));
  vec_float4 z2 = spu_splats(_x2(shape));
  vec_float4 x3 = spu_splats(_x3(shape));
  vec_float4 y3 = spu_splats(_y3(shape));
  vec_float4 z3 = spu_splats(_z3(shape));

  vec_float4 a = spu_madd(y1, spu_sub(z2, z3), spu_madd(y2, spu_sub(z3, z1), 
							spu_mul(y3, spu_sub(z1, z2))));

  vec_float4 b = spu_madd(z1, spu_sub(x2, x3), spu_madd(z2, spu_sub(x3, x1), 
							spu_mul(z3, spu_sub(x1, x2))));

  vec_float4 c = spu_madd(x1, spu_sub(y2, y3), spu_madd(x2, spu_sub(y3, y1), 
							spu_mul(x3, spu_sub(y1, y2))));

  vec_float4 t = spu_msub(y2, z3, spu_mul(y3, z2));
  vec_float4 d = spu_mul(x1, t);
  t = spu_msub(y3, z1, spu_mul(y1, z3));
  d = spu_madd(x2, t, d);
  t = spu_msub(y1, z2, spu_mul(y2, z1));
  d = spu_madd(x3, t, d);

  t = spu_madd(a, ox, spu_madd(b, oy, spu_mul(c, oz)));
  rs = spu_sub(d, t);
  t = spu_madd(a, dx, spu_madd(b, dy, spu_mul(c, dz)));
  rs = spu_mul(rs, spu_re(t));

  nx = spu_madd(rs, dx, ox);
  ny = spu_madd(rs, dy, oy);
  nz = spu_madd(rs, dz, oz);

  // find the equal axis
  flag = spu_and(mask0, spu_cmpeq(x1, x3));
  flag = spu_and(flag, spu_and(mask1, spu_cmpeq(y1, y3)));
  flag = spu_and(flag, spu_add(mask2, spu_cmpeq(z1, z3)));

  // count the leading zero as the equal axis
  index = spu_extract(spu_cntlz(spu_gather(flag)), 0);

  cmprs[0] = spu_xor(spu_cmpgt(x3, nx), spu_cmpgt(x1, nx));
  cmprs[1] = spu_xor(spu_cmpgt(y3, ny), spu_cmpgt(y1, ny));
  cmprs[2] = spu_xor(spu_cmpgt(z3, nz), spu_cmpgt(z1, nz));

  // mask the equaling axis
  cmprs[index] = spu_splats(1u);
  flag = spu_and(cmprs[0], spu_add(cmprs[1], cmprs[2]));
  rs = spu_sel(spu_splats(0.0f), rs, flag);
  
  return rs;
}
